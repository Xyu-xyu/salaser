import { makeAutoObservable, runInAction } from "mobx";
import { io, Socket } from "socket.io-client";
import constants from "./constants";

type ParamLimit = {
    name: string;
    measure: string;
    val: number;
};


class LaserStore {
	carouselInPlan: boolean = false;
	mainMode: string = "planMode";
	rightMode: Boolean = true
	knobMode: Boolean = false
	tasks:string[]  = [];
	loading: boolean = false;
	error: string | null = null;
	private intervalId: ReturnType<typeof setInterval> | null = null;
	loadResult:string= `{"success": true, "result": {"jobinfo": {}, "status": "IDLE", "mode": "NCP", "workarea": [3100, 2600]}}`
	centralBarMode:string = 'plans'
	socket: Socket | null = null;
	paramsLimit: ParamLimit[] = [
		{ name: 'X', measure: 'mm', val: 0 },
		{ name: 'Y', measure: 'mm', val: 0 },
		{ name: 'Z', measure: 'mm', val: 0 }
	];

	constructor() {
		makeAutoObservable(this);
	}


	setVal<T extends keyof this>(key: T, value: this[T]) {
		if (key in this) {
			this[key] = value;
		}
	}

	setTasks(tasks:string[]) {
		this.tasks = tasks;
	}

	setLoading(loading: boolean) {
		this.loading = loading;
	}

	setError(error: string | null) {
		this.error = error;
	}

	async fetchTasks() {
		this.setLoading(true);
/* 		try {
			const response = await fetch("/api/tasks-info"); // Vite proxy –∏–ª–∏ Flask build
			if (!response.ok) {
				throw new Error(`–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ${response.status} ${response.statusText}`);
			}
			const data = JSON.parse(response)

 			if (JSON.stringify(data) !== JSON.stringify(laserStore.tasks)) {
				this.setTasks(data);
			} 
		} catch (error: any) {
			this.setError(error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞");
		} finally {
			this.setLoading(false);
		} */
		this.setTasks(['—áacasca—É–π', 'gbpascaslf', 'scsacascas cacasca']);
		this.setLoading(false);
	}

	// –∑–∞–ø—É—Å–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ (polling)
	startPolling(intervalMs: number = 10000) {
		this.fetchTasks(); // –ø–µ—Ä–≤—ã–π –≤—ã–∑–æ–≤ —Å—Ä–∞–∑—É
		if (this.intervalId) clearInterval(this.intervalId);
		this.intervalId = setInterval(() => this.fetchTasks(), intervalMs);
	}

	// –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
	stopPolling() {
		if (this.intervalId) {
			clearInterval(this.intervalId);
			this.intervalId = null;
		}
	}

	initSocket() {
        if (laserStore.socket) return; // —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º

		//let lastUpdate = 0;

        this.socket = io(constants.SERVER_URL, {
            path: "/socket.io",
            transports: ["websocket"],
        });

        this.socket.on("connect", () => {
            console.log("‚úÖ Connected to backend");
        });

        this.socket.on("disconnect", () => {
            console.log("‚ùå Disconnected from backend");
        });

        this.socket.on("machine_data", (data: any) => {
			//const now = Date.now();
			//if (lastUpdate) {
				//const diff = now - lastUpdate;
				//console.log(`‚è± –í—Ä–µ–º—è –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏: ${diff} –º—Å`);
			//}
		
			//lastUpdate = now;
            runInAction(() => {
			    this.paramsLimit = data; // –æ–±–Ω–æ–≤–ª—è–µ–º observable-—Å–≤–æ–π—Å—Ç–≤–æ
            });
        });
    }

    /** –û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–æ–∫–µ—Ç–∞ –∏ –æ—á–∏—Å—Ç–∫–∞ */
    closeSocket() {
        if (this.socket) {
            this.socket.off("machine_data");
            this.socket.disconnect();
            this.socket = null;
            console.log("üîå Socket disconnected");
        }
    }  

}

const laserStore = new LaserStore();
laserStore.initSocket()

export default laserStore;